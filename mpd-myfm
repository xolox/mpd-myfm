#!/usr/bin/env python

#Import with statement from __future__ to support python 2.5
from __future__ import with_statement
import grp
import logging
import logging.handlers
import optparse
import os
import pwd
import re
import socket
import sys
import time


class MPD_MyFM(object):
    def __init__(self, options, parser, logger):
        self.logger = logger
        self.logger.info('Started mpd-myfm client')
        self.options = options
        self.logger.debug('logging Level = %i', self.options.loglevel)
        if self.options.pidfile:
            pidfile = self._create_pid_file()
        self._chown()
        if self.options.pidfile:
            # Don't close the PID file unless it was actually opened!
            pidfile.close()

        self.client = mpdunicode.MPDClient()
        if not self._connect():
            self.logger.error(
                    "Failed to connect to MPD server at `%s' on port `%i'",
                    self.options.hostname, self.options.portnr)
            if not self.options.daemonize:
                parser.print_help()
                sys.exit(1)
            else:
                # If daemonized we should not exit on any connection failure.
                while not self._connect():
                    self.sleep(10)

        self.generator = self._new_generator()

        self.logger.info("Done... Now starting main program loop.")
        self.run()

    def run(self):
        while 1:
            try:
                if self.clientenabled():
                    playlist = self.client.playlistinfo()[- self.options.repeatfactor:]
                    if self.options.albummode:
                        album = self.generator.get_next_album(playlist)
                        self.client.command_list_ok_begin()
                        try:
                            for song in album.songs:
                                self.client.add(song.file.absolute)
                        finally:
                            self.client.command_list_end()
                    else:
                        song = self.generator.get_next_song(playlist)
                        self.client.add(song.file.absolute)
                # Sleep for a while before trying to update again.
                changes = self.client.idle(['player', 'playlist', 'database'])
                if 'database' in changes:
                    self.generator = None
                    self.generator = self._new_generator()
            except (socket.error, mpdunicode.ConnectionError), msgconerrer:
                self.logger.error('Lost connection to mpd server? (%s)', msgconerrer)
                # Try to close the connection in case it's still open.
                try:
                    self.client.disconnect()
                except:
                    pass
                # Sleep for a while before trying to reconnect.
                self.sleep(options.reconnecttime)
                # Loop until we're connected to MPD again.
                while not self._connect():
                    self.sleep(options.reconnecttime)
            except (SystemExit, KeyboardInterrupt):
                self.logger.info('mpd-myfm is stopping transmission.')
                self.quit(0)
            except:
                # TODO: get track that caused crash in error log.
                self.logger.error('mpd-myfm has encountered a problem and will now exit.')
                self.quit(None)
                # We raise a RuntimeError here in stead of exit otherwise the
                # stack gets printed by both the logging module and by the standard
                # python stack tracer.
                raise RuntimeError

    def _new_generator(self):
        # Use an iterator for the loading of the library. This saves massive amounts of memory.
        self.client.iterate = True
        library = self.client.listallinfo()
        gen = generator.Playlist_genrator(library, self.options.lastfmaccount, self.logger)
        self.client.iterate = False
        return gen

    def _create_pid_file(self):
        if os.path.exists(self.options.pidfile):
            try:
                pidfile = open(self.options.pidfile, 'rw')
                pid = pidfile.read(8)
                if os.path.exists('/proc/%s' % pid) and pid != '':
                    self.logger.warning(
                            'The pidfile (%s) points to an existing process, mpd-myfm is probably already running.',
                            self.options.pidfile)
                    if self.options.daemonize:
                        self.logger.warning(
                                'If you are sure mpd-myfm is not running you can remove %s and run mpd-myfm again.',
                                self.options.pidfile)
                        raise RuntimeError
                    else:
                        self.logger.warning('Not using pidfile, since it is already in use by another process')
                        self.options.pidfile = ''
                else:
                    self.logger.warning('reusing stale pidfile (%s)', self.options.pidfile)
                    pidfile = open(self.options.pidfile,'w')
                    pidfile.write(str(os.getpid()))
            except OSError, error:
                self.logger.error('An error occurred while creating the pidfile: %s', error)
        else:
            pidfile = open(self.options.pidfile,'w')
            pidfile.write(str(os.getpid()))
            # We close pidfile handle later so the chown doesn't fail.
        return pidfile

    def _chown(self):
        if self.options.effectivegroup and os.getuid() == 0:
            gid = grp.getgrnam(self.options.effectivegroup)[2]
            try:
                os.chown(self.options.pidfile, -1, gid)
            except OSError:
                self.logger.error('Could not change group of %s.', self.options.pidfile)
            try:
                os.setgid(gid)
            except OSError:
                self.logger.error('Could not set group to %s.', self.options.effectivegroup)
                raise RuntimeError

        if self.options.effectiveuser and os.getuid() == 0:
            uid = pwd.getpwnam(self.options.effectiveuser)[2]
            try:
                os.chown(self.options.pidfile, uid, -1)
            except OSError:
                self.logger.error('Could not change ownership of %s.', self.options.pidfile)
            try:
                os.setuid(uid)
            except OSError:
                self.logger.error('Could not set user to %s.', self.options.effectiveuser)
                raise RuntimeError

    def clientenabled(self):
        status = self.client.status()
        if int(status['playlistlength']) == 0:
            self.logger.log(7, "Doing nothing because play list is empty.")
            return False
        if int(status['random']) != 0:
            self.logger.log(7, "Doing nothing because random is enabled.")
            return False
        if int(status['repeat']) != 0:
            self.logger.log(7, "Doing nothing because repeat is enabled.")
            return False
        songsleft = int(status['playlistlength']) - int(status.get('song', -1))
        if songsleft > self.options.songsleft:
            self.logger.log(7, "Doing nothing because the end of the play list hasn't been reached.")
            return False
        return True


    def sleep(self, seconds):
        self.logger.log(5, 'Sleeping for %i seconds', seconds)
        time.sleep(seconds)

    def _connect(self):
        try:
            self.client.connect(self.options.hostname, self.options.portnr)
            if self.options.passwd:
                self.client.password(self.options.passwd)
            return True
        except socket.error:
            return False

    def quit(self, exit_code):
        self.cleanup()
        if exit_code is not None:
            sys.exit(exit_code)

    def cleanup(self):
        try:
            self.client.close()
        except:
            if self.logger:
                self.logger.error('Could not close connection to the MPD server at %s.', self.options.hostname)
        try:
            if self.options.pidfile and os.path.exists(self.options.pidfile):
                os.remove(self.options.pidfile)
        except:
            if self.logger:
                self.logger.error('Could not remove pidfile: %s', self.options.pidfile)

def getoptions():

   def setdefaults():
      # Define option defaults.
      defaults = {
            'hostname': '127.0.0.1',
            'portnr': 6600,
            'passwd': '',
            'songsleft': 3,
            'updatetime': 5,
            'reconnecttime': 60,
            'repeatfactor': 20,
            'albummode': False,
            'logfile': '',
            'daemonize': False,
            'loglevel': 0,
            'lastfmaccount': '',
            'pidfile': '',
            'userconfig': '~/.mpd-myfm',
            'configfile': '/etc/mpd-myfm.conf',
            'modulepath': '/usr/local/lib/python%s/site-packages/mpd-myfm' % sys.version[:3],
            'effectiveuser': '',
            'effectivegroup': ''}

      return defaults

   def callback(option, opt_str, value, parshandle):
      parseconfigfile(value, parser=parshandle)

   def parseconfigfile(configfile, defaults={}, parser=''):
      if os.path.exists(configfile):
         handle = open(configfile, 'r')
         fileconfig = []
         fileconfig=(handle.read().split('\n'))
         handle.close()
         for line in fileconfig:
            if not re.match('^\s*(#.*)?$', line):
               line = re.sub('\s*', '', line)
               optkey, optarg = line.split('=')
               optkey = optkey.lower()
               if parser:
                  if optkey == 'hostname' or optkey == 'passwd' or optkey == 'lastfmaccount':
                     setattr(parser.values, optkey, optarg)
                  elif re.match('[0-9]', optarg):
                     setattr(parser.values, optkey, int(optarg))
                  else:
                     setattr(parser.values, optkey, optarg)
               else:
                  if optkey == 'hostname' or optkey == 'passwd' or optkey == 'lastfmaccount':
                     defaults[optkey]=optarg
                  elif re.match('[0-9]', optarg):
                     defaults[optkey]=int(optarg)
                  else:
                     defaults[optkey]=optarg
      return defaults

   class MyFmHelpFormatter (optparse.HelpFormatter):
      """
      Format help with underlined section headers.
      """

      try:
         rows, columns = os.popen('stty size 2> /dev/null', 'r').read().split()
      except:
         columns = 80
      finally:
         columns = int(columns) - 5

      def __init__(self,
                   indent_increment=2,
                   max_help_position=35,
                   width=columns,
                   short_first=1):
         optparse.HelpFormatter.__init__ (
                  self, indent_increment, max_help_position, width, short_first, )

      def format_usage(self, usage):
         return self.format_heading(optparse._("Usage:  %s" % usage ))

      def format_heading(self, heading):
         return "%s\n%s\n" % (heading, "=-"[self.level] * len(heading) )


   # Parse config files, first system wide then the userconfig to override options set in both.
   defaults = setdefaults()
   if os.path.exists('/etc/mpd-myfm.conf'):
      defaults = parseconfigfile('/etc/mpd-myfm.conf', defaults)
   if os.path.exists(os.path.expanduser(defaults['userconfig'])) and os.getuid() != 0:
      defaults = parseconfigfile(os.path.expanduser(defaults['userconfig']), defaults)

   # Parse command line, this will override the config file settings.
   # If a config file is set via the command line the options defined in that config file will
   # be inserted at that point in the command line overriding any options given earlier on the commandline
   # that also exist in the specified config file.
   parser = optparse.OptionParser(formatter=MyFmHelpFormatter())
   parser.add_option('-c', '--configfile', help='Specify which configuration file to use (best given as first option).', metavar='FILE', type='str', action='callback', callback=callback)
   parser.add_option('-H', '--host', dest='hostname', help='host name of Music Player Daemon', metavar='HOST', default=defaults['hostname'])
   parser.add_option('-p', '--port', dest='portnr', help='port number on which MPD is listening', metavar='PORT', type='int', default=defaults['portnr'])
   parser.add_option('-P', '--pass', dest='passwd', help='password for connecting with MPD', metavar='PASS', default=defaults['passwd'])
   parser.add_option('-r', '--reconnect', dest='reconnecttime', help='seconds before client tries to reconnect', metavar='SEC', type='int', default=defaults['reconnecttime'])
   parser.add_option('-u', '--update', dest='updatetime', help='seconds between updates to the playlist', metavar='SEC', type='int', default=defaults['updatetime'])
   parser.add_option('-s', '--songs', dest='songsleft', help='number of tracks before end of playlist to start adding songs', metavar='NUM', type='int', default=defaults['songsleft'])
   parser.add_option('-R', '--repeat', dest='repeatfactor', help='number of last played tracks not to repeat', metavar='NUM', type='int', default=defaults['repeatfactor'])
   parser.add_option('-l', '--lastfm', dest='lastfmaccount', help="play tracks loved by user on Last.fm more frequently and don't play banned tracks", metavar='USERNAME', default=defaults['lastfmaccount'])
   parser.add_option('-A', '--album', dest='albummode', help='add whole albums instead of just one track.', action='store_true', default=defaults['albummode'])
   parser.add_option('-L', '--logfile', dest='logfile', help='Copy script output to file.', metavar='FILE', default=defaults['logfile'])
   parser.add_option('-M', '--modulepath', dest='modulepath', help='Directory where the modules that came with mpd-myfm are stored.', metavar='/PATH/TO/', default=defaults['modulepath'])
   parser.add_option('-D', '--daemonize', dest='daemonize', help='Detatch from consolle.', action='store_true', default=defaults['daemonize'])
   parser.add_option('-F', '--pidfile', dest='pidfile', help='process identifier file to use.', metavar='FILE', default=defaults['pidfile'])
   parser.add_option('--userid', dest='effectiveuser', help='Name of the useraccount to run as if daemonized.', metavar='USERNAME', default=defaults['effectiveuser'])
   parser.add_option('--groupid', dest='effectivegroup', help='Name of the group to run in if daemonized.', metavar='GROUPNAME', default=defaults['effectivegroup'])
   parser.add_option('--loglevel', dest='loglevel', help='Set the amount of messages that get logged to the logfile and console. (1-10)', type='int', metavar='NUM', default=defaults['loglevel'])
   (options, args) = parser.parse_args()

   return options, parser


def _createlog(options):
    logger = logging.getLogger('mpd-myfm')
    logger.setLevel(options.loglevel)
    formatter = logging.Formatter(fmt='%(asctime)s - %(levelname)s - %(message)s')
    if options.logfile:
        file_handler = logging.handlers.RotatingFileHandler(
                options.logfile,
                mode='a',
                maxBytes=5*1024*1024,
                backupCount=3,
                encoding='UTF-8',
                delay=1)
        file_handler.setFormatter(formatter)
        logger.addHandler(file_handler)
    if not options.daemonize:
        console_handler = logging.StreamHandler(stream=sys.stdout)
        console_handler.setFormatter(formatter)
        logger.addHandler(console_handler)
    return logger


if __name__ == '__main__':
    options, parser = getoptions()
    sys.path.append(options.modulepath)
    logger = _createlog(options)
    try:
        if options.daemonize:
            import daemon
            try:
                with daemon.DaemonContext():
                    import mpdunicode
                    import generator
                    MPD_MyFM(options, parser, logger)
            except daemon.daemon.DaemonError, error:
                logger.exception('Could not Daemonize:', error)
        else:
            import mpdunicode
            import generator
            MPD_MyFM(options, parser, logger)
    except ImportError, module:
        logger.exception('An error has occurred during the importing of modules: %s.', module)

